import os
import shutil
import subprocess
from pathlib import Path
from typing import Optional, List

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
from tqdm import tqdm
import time

# Set Kaggle credentials
os.environ['KAGGLE_USERNAME'] = 'your api name'
os.environ['KAGGLE_KEY'] = 'your api key'

class Extract:
    def __init__(
        self,
        dataset: str = "sobhanmoosavi/us-accidents",
        extract_dir: str = r"give a path of a new folder",
        delete_zip_after_unzip: bool = True,
        encoding: str = "utf-8",
        verbose: bool = True,
    ):
        self.dataset = dataset
        self.extract_dir = Path(extract_dir)
        self.extract_dir.mkdir(parents=True, exist_ok=True)
        self.delete_zip_after_unzip = delete_zip_after_unzip
        self.encoding = encoding
        self.verbose = verbose

        # 1) Check Kaggle CLI
        if shutil.which("kaggle") is None:
            raise EnvironmentError(
                "Kaggle CLI not found. Install with 'pip install kaggle' and ensure 'kaggle' is on PATH."
            )

        # 2) Download and unzip if CSV not found
        if not self._has_csv_in_dir():
            if self.verbose:
                print(f"Downloading dataset: {self.dataset} to {self.extract_dir}")
                with tqdm(total=1, desc="Downloading", bar_format="{l_bar}{bar}| {elapsed}") as pbar:
                    proc = subprocess.Popen(
                        ["kaggle", "datasets", "download", "-d", self.dataset, "-p", str(self.extract_dir), "--unzip"],
                        stdout=subprocess.PIPE, stderr=subprocess.PIPE
                    )
                    while proc.poll() is None:
                        time.sleep(0.5)
                        pbar.update(0)
                    pbar.update(1)

                if proc.returncode != 0:
                    raise RuntimeError(f"Failed to download dataset: {self.dataset}. Error: {proc.stderr.read().decode()}")

                if self.verbose:
                    print("Download complete and unzip complete.")

                if self.delete_zip_after_unzip:
                    for z in self.extract_dir.glob("*.zip"):
                        try:
                            z.unlink()
                        except Exception:
                            pass

        # 3) Locate the US Accidents CSV
        csv_path = self._find_accidents_csv()
        if not csv_path:
            raise FileNotFoundError(
                f"No US_Accidents*.csv found in {self.extract_dir}. "
                "Please verify the dataset contents."
            )

        self.csv_path = str(csv_path)
        if self.verbose:
            print(f"Using CSV: {self.csv_path}")

        # 4) Load the CSV with a robust fallback for encoding
        try:
            self.df = pd.read_csv(self.csv_path, encoding=self.encoding, low_memory=False)
        except UnicodeDecodeError:
            self.df = pd.read_csv(self.csv_path, encoding="utf-8-sig", low_memory=False)

    def _has_csv_in_dir(self) -> bool:
        """
        Returns True if any CSV that looks like the US Accidents dataset exists in extract_dir.
        """
        patterns: List[str] = ["US_Accidents*.csv", "*.csv"]
        for pat in patterns:
            if any(self.extract_dir.glob(pat)):
                return True
        return False

    def _find_accidents_csv(self) -> Optional[Path]:
        """
        Returns a Path to the first CSV found (prefer US_Accidents*.csv).
        """
        preferred = sorted(self.extract_dir.glob("US_Accidents*.csv"))
        if preferred:
            return preferred[-1]
        any_csv = sorted(self.extract_dir.glob("*.csv"))
        return any_csv[-1] if any_csv else None


if __name__ == "__main__":
    extract = Extract(
        dataset="sobhanmoosavi/us-accidents",
        extract_dir=r"give a path of the new folder\us_accidents",
        delete_zip_after_unzip=True,
        encoding="utf-8",
        verbose=True,
    )

    # Example: show the first 5 rows to confirm data loaded
    print(extract.df.head())
